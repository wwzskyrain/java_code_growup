# 家庭盘子水果游戏
## 1.整体介绍
1. 该线程模拟的是一个家庭盘子水果游戏，游戏逻辑是这样的：
    ```
        1.  妈妈如果发现盘子为空，就往里面放一个橘子；
        2.  爸爸如果发现盘子为空，就往里面放一个苹果
        3.  儿子发现盘子里有一个苹果，就拿起苹果吃了它；
        4.  女儿发现盘子里有一个橘子，就拿起橘子吃掉它；
    ```
2.  希望通过这游戏模拟（或许你会说这算什么游戏啊，一点都没意思；好吧我承认），体会下wait和notifyAll使用

## 2.程序框架
该模拟程序一共有四个线程类和两个拟生类和一个Main类已经一个Util类组成，分别介绍
1.  四个线程类分别是`ThreadFather`，`ThreadMother`，`ThreadDaughter`，`ThreadSon`，其按照`整体介绍`中的逻辑运行
2.  两个拟生类分别是Fruit和Plate，分别表示水果和盘子，而橘子和苹果，则用具有不同name属性值的"水果"实例来表示。
3.  工具类Util只定义了一个静态变量，用于统一控制四个线程的休眠时间；Main类是FamilyPlateGameSynVersion，则用来开启线程，并在最后给他们发中断信号。

## 3.程序运行流程
通过FamilyPlateGameSynVersion启动后，整个模拟逻辑会一直运行下去，直到主线程在给定时间后中断四个线程。



## 4.细节介绍

### 1.锁、阻塞和唤醒(重点)
四个线程都会竞争同一把锁，那就是"盘子"；拿到锁的线程，会循环判断它所关心的条件，如果条件不成立，
则"阻塞"自己；如果成立则跳出循环，从而进入它本身的逻辑操作。
爸爸、妈妈、儿子、女儿各自有各自的循环判断条件，各自有各自的操作逻辑。
整个程序运行起来后，会在"吃水果"、"放水果"这两类动作交替运行。下面对重点细节进行介绍
1.  有死锁的概率吗?
当然没有啦。
    1.  无论使用【1】【2】【3】中的那一句初始化，也无论要不要给每个执行逻辑后添加一个小休眠，程序都不可能产生死锁。
    2.  无论notifyAll的时候，是否有线程阻塞在锁plate上，都不会产生死锁；所以不用担心，notifyAll会通知为空的情况
    3.  对1，2进行解释。四个线程是先后(具体次序无所谓)进入synchronize块中的，这样必有一个的条件判断失败从而跳过while，
    因为我们的条件判断是一个全局检查，所以总会有一个判断是成立的。从而也即是不会阻塞(wait)在锁上。
    然后这个线程就正常的逻辑操作，然后调用notifyAll，从而激发下一次大家对锁的竞争和条件判断；
    ```
        问题补充：在四个线程先后进入synchronize块，数据状态就不会恰好改变吗？
        问题回答：问的很妖；只要有数据状态改变，紧接着就会有notifyAll操作，这是时就直接激发了下一波大家
                对锁的竞争和条件判断了。
    ```

2.  三个地方都有退出逻辑，三处都是有必要的吗？  有的

线程池的发送中断信号的时候，四个线程的除了在wait和sleep会接收到，还有就是主动去判断中断位置，就是在for循环的开始。


总结：
    1.阻塞和唤醒一定是在synchronize中。
    2.阻塞条件一定要循环检查，而且循环体中只有一个阻塞语句。
    3.阻塞是可以被中断的，所以要做响应中断，比如break跳出循环检查，甚至跳出return
    4.如果把线程的sleep注释掉，那么线程会从for循环的入口处响应中断，并且break跳出循环，从而run方法运行完毕，线程结束。

3.  通过自定义线程类，来使线程接受参数
4.  关于线程池的shutdownNow的语义，以及设置中断位，中断响应，这些都不在此解释。

## 5.总结
这是synchronize关键字版本的"盘子游戏"，还可以很容易的写成对应的lock版本的。